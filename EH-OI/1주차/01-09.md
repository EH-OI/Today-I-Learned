# 1/9

## 1. Spring vs Spring Boot

**1.1 Spring Boot란 무엇인가**

스프링 프레임워크를 쉽게 사용하기 위한 도구

스프링 프레임워크 + 톰캣 서버 내장

톰캣: JSP, 서블릿 처리, 서블릿 수명주기 관리, 요청 url 서블릿 코드로 매핑, http 요청 수신 및 응답, 필터 체인 관리 등

**1.2 Spring Framework와 Spring Boot의 차이**

1. Dependency(의존성관리)
    - 스프링 프레임워크
        - 필요 라이브러리 하나씩 직접 추가
        - 각 dependency마다 버전 관리 필요 → 파일 길고 복잡
    - 스프링부트
        - spring-boot-starter-* 의존성 사용
        - 용도에 따라 필요한 라이브러리를 한번에 자동 관리
        - 버전 충돌을 대신 해결
2. Configuration
    - 스프링 프레임워크
        - 설정 클래스, 어노테이션, Bean 등록을 모두 직접 작성
    - 스프링부트
        - 대부분 자동 처리
        - [application.properties](http://application.properties) / application.yml

+) 2.1. AutoConfiguation(스프링부트)

@SpringBootApplication 어노테이션을 통한 동작(외부 라이브러리, 내장 톰캣 서버 등 실행)

- @ComponentScan : @Component, @Controller, @Service, @Repository → 자동 Bean 등록
- @EnableAutoConfiguration: 클래스패스 기반 조건에 맞는 Bean 자동 등록
1. 배포
    - 스프링 프레임워크 개발 - WAR 파일을 웹 어플리케이션 서버에 담아 배포
    - 스프링부트 개발 - 내장 WAS(Tomcat, Jetty)를 가지기 때문에 Jar 파일로 간편하게 배포
    

**1.3 설정 방식과 초기 구성 비교**

- 스프링 프레임워크
    - XML(applicationContext.xml)
    - Java Config(@Configuration)
    - DataSource, Transaction, Component Scan 등 전부 직접 설정
- 스프링부트
    - @SpringBootApplication → 기본설정 자동 적용, 필요한 경우만 오버라이드

**1.4 Auto-configuration의 의미와 동작 원리**

클래스패스에 있는 라이브러리를 기반으로 스프링이 알아서 설정을 구성해주는 기능

조건 만족 시 Bean 자동 등록

위에서 동작 설명(1.2-2.1)

**1.5 의존성 관리 전략**

- 스프링 프레임워크
    
    의존성 하나씩 직접 추가 → 버전 충돌 위험
    
    - DI: 객체가 직접 의존 객체를 생성하지 않고 스프링 컨테이너가 의존 객체를 생성 및 주입하는 방식 → 결합도 감소
        - XML
        - Java Config(@Configuation, @Bean)
        - 어노테이션 기반(@Component, @Autowired)
    - Maven/Gragle: 필요한 라이브러리를 개발자가 직접 명시하여 각 라이브러리의 버전을 직접 관리 → 의존성 충돌 가능성 O
        - 설명 파일 길어지고 라이브러리 간 버전 충돌
        - 테스트, 보안, 로깅 라이브러리까지 수동 관리 → 규모 커질수록 관리비용 증가
- 스프링부트
    - spring-boot-starter: 프로젝트 구성에 필요한 의존성 자동 가져옴
        - 추가된 스타터에 맞춰 스프링 빈, 서블릿, 로깅 등 자동구성
        - spring-boot-starter-parent: 버전 명시 → dependency 라이브러리의 버전을 따로 명시해주지 않아도 선언된 버전으로 가져옴
    - gradle/plugin
        - io.spring.dependency-management 플러그인 적용 → 스프링부트의 플러그인이 스프링부트 저번에 따라 자동으로 spring-boot-dependencies bom 가져옴
        

**1.6 실행 및 배포 모델의 차이**

- 스프링 프레임워크
    - WAR 파일 만들고 톰캣(외부 WAS) 설치하여 그 위에 배포
- 스프링부트
    - 내장된 WAS가 포함된 JAR 파일로 빌드 → 외부 서버 없이 java -jar 명령어로 실행 가능
    

**1.7 운영 관점 차이** 

- 헬스체크
    - 스프링 프레임워크
        - 직접 엔드포인트 구현
        - 실제 의존성 상태 확인 불가, 문자열 반환 수준
    - 스프링부트: Actuator 제공
        - 기본 제공 엔드포인트가 있고 DataSource, Redis, Disk Space 자동 체크
- Metrics
    - 스프링 프레임워크: 기능 없음
    - 스프링부트: Micrometer 통합, Actuator와 연계
        - HTTP 요청 수/응답 시간, JVM 메모리, GC, 스레드 수, DB 커넥션 풀
- 환경 분리(Profiles)
    - 스프링 프레임워크: 직접 설정(XML, Java Config)
    - 스프링 부트: 기본 지원
- 로깅
    - 스프링 프레임워크: 수동
    - 스프링부트: 기본 로깅 설정(Logback+SLF4J)
    

**1.8 설정 외부화와 프로퍼티 관리**

외부 입력 값(환경에 따라 달라지는 값)을 소스코드 외부에서 관리하기 위해 사용

→ 소스코드 수정 없이 설정 변경 가능, 배포 환경처럼 소스코드 수정 불가한 상황에서도 유연한 운영 가능

- application.properties
    - .properties 에 정의(line) - 중복 많아짐
- application.yml
    - 들여쓰기 & 한 파일에서 관리 가능 → 가독성
    - 들여쓰기(space) 주의
    

## 2. JAR vs WAR

- JAR
    - Java 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일
    - 클래스, 라이브러리 파일 포함
    - JRE만 있어도 실행 가능
    - 내장 톰캣
- WAR
    - 서블릿, Jsp 컨테이너에 배치할 수 있는 웹 애플리케이션 압축파일 포맷
    - 웹 관련 자원 포함 - JSP, Servelt, JAR, Class, XML, HTML, JavaScript
    - 사전 정의된 구조 사용(WEB-INF, META-INF)
    - 별도 웹서버(WEB) 또는 웹 컨테이너(WAS)필요
    - WAS에 배포 - WAS 하나에 여러 앱

## 3. 컴포넌트 스캔 (Component Scan)

3.1 Spring Framework의 컴포넌트 스캔

Bean으로 등록될 준비를 마친 클래스를 스캔 → Bean으로 등록

빈으로 등록될 준비를 한다 = @Controller, @Service, @Component, @Repository 어노테이션을 붙인 클래스

- xml 파일에 설정
    
    ```jsx
    <context:component-scan base-package="com.rcod.lifelog"/> 
    ```
    
    xml 파일에 설정 + base package 작성 → base package 기준으로 클래스 스캔, 빈 등록
    
    ```jsx
    <context:component-scan base-package="com.rcod.lifelog, com.rcod.example"/>
    ```
    
    base package 하위 @Controller, @Service, @Component, @Repository 클래스를 모두 빈으로 등록
    
    → 특정 객체만 빈으로 등록하고 싶다면 include-filter/exclue filter 로 설정
    
    - exclude-filter
    
    ```jsx
    <context:component-scan base-package="com.rcod.lifelog">
        <context:exclude-filter type="annotation" 
            expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    ```
    
    ex) @Controller를 제외하고 싶을때 exclude-filter를 사용해 org.springframework.stereotype.Controller 를 명시
    
    - include-filter
    
    ```jsx
    <context:component-scan base-package="com.rcod.lifelog" use-default="false">
        <context:include-filter type="annotation" 
            expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    ```
    
    use-default=false: 기본 어노테이션을 스캔하지 않음
    
    기본 어노테이션 스캔 빼고 include-filter로 특정 어노테이션만 스캔 설정
    
- 자바 파일안에서 설정
    
    ```jsx
    @Configuration
    @ComponentScan(basePackages = "com.rcod.lifelog")
    public class ApplicationConfig {
    }
    ```
    
    @Configuration: 이 클래스가 xml을 대체하는 설정 파일임을 알려줌
    
    해당 클래스를 설정 파일로 설정하고 @ComponentScan을 통해 basePackages를 설정
    
- 동작 과정
    1. ConfigurationClassParser 가 Configuration 클래스를 파싱
        
        @Configuration 어노테이션 클래스를 파싱하는 것이다.
        
    2. ComponentScan 설정을 파싱
        
        base-package 에 설정한 패키지를 기준으로 ComponentScanAnnotationParser가 스캔하기 위한 설정을 파싱
        
    3. base-package 설정을 바탕으로 모든 클래스를 로딩
    4. ClassLoader가 로딩한 클래스들을 BeanDefinition으로 정의 (생성할 빈의 대한 정의)
    5. 생성할 빈에 대한 정의를 토대로 빈 생성

3.2 Spring Boot의 컴포넌트 스캔

- @ComponentScan: 특정 패키지를 스캔 → 해당 패키지와 하위 패키지에 있는 @Component, @Service, @Repository, @Controller 등 어노테이션이 붙은 클래스를 자동으로 빈 등록
- DI 자동 처리 - @Autowired

```jsx
@Configuration
@ComponentScan(basePackages = "com.example.demo") // 이 패키지와 하위 패키지를 스캔
public class AppConfig {
}
```

basePackages: basePackages로 지정된 경로부터 시작, 하위 모든 패키지 모두 스캔

![image.png](1%209/image.png)

- @SpringBootApplication에 이미 @ComponentScan이 포함됨 - Spring Boot Application에서는 별도 명시 안해도됨
    
    ```jsx
    @SpringBootApplication
    public class DemoApplication {
        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }
    }
    ```
    

- 컴포넌트 스캔을 통해 등록된 Bean들은 @Autowired로 자동 의존성주입 가능
