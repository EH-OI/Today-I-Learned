# 1/21

## 도메인 단

### 엔티티 어노테이션(@Entity)

가장 중요한 어노테이션

- @Entity가 붙은 클래스는 DB 테이블과 매핑되는 객체 ⇒ JPA가 관리하는 대상(영속성 컨텍스트, 영속 객체)이 됨
- JPA/Hibernate
    - SQL 생성
    - INSERT, UPDATE, SELECT
    - 변경 감지
    - 를 자동으로 수행함
- 엔티티 단이라는것을 알려줘서 jpa로 연결:
    - @Entity는 영속성 컨텍스트의 관리 대상이므로, DB와 직접 연결되는 것이 아닌 EntityManager(JPA 내부 객체)를 통해 관리
    
    *영속성 컨텍스트
    
    엔티티 객체의 생명주기를 관리하는 공간
    

### 테이블 어노테이션

이 엔티티가 어떤 테이블인지 명시

네임(생략하면 클래스이름), 스키마, 제약조건 등이 들어가있음

### getter/setter

- 필드(멤버변수)는 private 접근제어자를 통해 객체 외부에서 객체의 필드에 직접적으로 접근하는 것을 막음
- Getter, Setter 메서드는 public 접근제어자를 통해 외부에서 접근 가능하도록 함, 필드값 사용 및 수정함
- Get/Set + 필드이름(대문자 시작) 명명

- get해서 멤버변수 가져옴(return)
    
    외부에서 객체의 데이터를 읽을 때 사용
    
- set해서 멤버변수 값 넣음(매개변수)
    
    보통 도메인 단에서 잘 안 씀, 일관되게 값을 변경하지 못하기 때문에 업데이트 메소드를 따로 만들어서 사용함
    
    외부에서 객체의 데이터를 수정할 때 사용
    

### id 어노테이션

해당 테이블의 pk를 나타냄

해당 컬럼의 이름을 어떻게 짓든지 상관없이 이름을 찾아줌

JPA는 @Id 기준으로 엔티티 식별 - findById 사용

### generated value

해당 아이디를 어떻게 생성할지에 대한 생성 전략을 나타냄(pk 생성 전략)

→ 어노테이션은 db 단에서 자동으로 값 입력됨

### 컬럼 어노테이션

컬럼임을 인지시켜줌

- nullable: DB NOT NULL
- updatable = false: 생성되는 순간부터  값을 못 바꿈
- column definition
    - 도메인 제약조건을 걸어줌, DDL 직접 작성
    - DB 종속적
- column default(Hibernate)
    - JPA 레벨 기본값

- 날짜 → LocalDate 사용
- 컬럼 값 수정 불가하게 하려면 updatable = false

### convention

규칙, 다른 사람과 협업할 때 누가 봐도 이런 코드임을 알 수 있게끔 지정

### Enum

스트링으로 많이 씀 → db에서 토글 형식으로 내려옴

추가 삭제 순서변경의 경우에 db 값이 싹다 바뀌는 대참사를 막기 위해 스트링으로 사용

- tiny int: boolean = tinyint(1)
    - 0 = false
    - 1 = true
    

### date/time

컬럼에서도 java.time.LocalDate를 사용해야 함

Hibernate 에서 자동으로 로컬데이트로 바꿔줌

→ JWT, Security, DB 모두 java.time 사용

### 커넥션 풀

커넥션 = 객체

많다고 좋은게 아님 → 객체가 많아져서 속도 저하

커넥션을 관리하는 알고리즘이 다름

- HikariCP
    - 빠름, 최소한의 락
    - 스프링부트 기본 채택
    - DB CP보다 빠름 ← 알고리즘 차이

---

## Repository 계층

데이터 접근 담당 - DB에 쿼리 날려서 결과를 객체로 돌려줌

jpa 레포지토리 사용

- SQL 직접 작성 X, 인터페이스만 정의
- save, delete, findById 등 기능 ← 함수가 자동으로 생성됨

쿼리 어노테이션을 사용해서 오버라이딩이나 새로운 함수를 만들어줄 수도 있음

### page 클래스

page 클래스: 결과 + 페이지 정보를 함께 담는 객체

- 페이징, 정렬, 총 개수 자동 계산
- pagenation에 사용

### null을 확인해주는 객체: optional

유저 레포지토리에서 findById → 유저에 매핑을 시켜서 유저클래스로 반환

이때 null일수도 있고 아닐수도 있는데

*아이디는 항상 어노테이션 기준으로 찾아줌

null로 들어오면 nullPointException 위험

→ 이런걸 처리하기 위한 객체가 optional

null을 방치하지 않고 강제로 체크하게 만듦

- List는 null 이 없음 → Optional 필요 X

### jpa

기본적으로는 무조건 엔티티(유저) 반환

다른 형태(특정 이름)을 반환하고 싶으면 DTO를 만들어서 명시적으로 알려줘야 함

*DTO: 데이터를 전달(만)하기 위한 객체

로직을 가지지 않는 순수한 객체(getter & setter만 가짐)

여러 레이어간 데이터를 주고받을 때 사용가능하고, View ↔ Controller 사이에서 주로 사용

또는 인터페이스 Projection 으로 따로 작성(get 필요)

이렇게 안하면 기본적으로 유저 반환(리스트 형태 → list user)

JPA는 엔티티를 중심으로 설계되기 때문에, 아무 지정을 안 하면 User를 반환하는게 기본

User가 아닌 다른 형태로 받고 싶으면 JPA에게 알려줘야 함

---

## 서비스단

비즈니스 로직만 작성

- 서비스 어노테이션: 이 클래스가 서비스 역할임을 알려주고 객체를 자동 생성 및 관리
- 생성자 어노테이션(생성자 주입을 위한): 이 서비스가 어떤 repository를 사용하는지 명확히 함
- 트랜잭셔널 어노테이션: 여러 DB 작업을 하나의 작업 단위로 묶는 것
    
    전부 성공 → 커밋, 하나라도 실패 → 롤백 등
    
    - isolation level
    - 트랜잭션이 실패했을 때 어떤 것을 롤백할지
        - 기본: RuntimeException
        - 설정: 특정 예외, 체크 예외 롤백 가능
        - transaction after commit annotation: 커밋 이후에 무엇을 실행시킬지 지정
- 로그
    - System.out.println
    - SLF4J: 로깅 프레임워크

### 빌더

엔티티를 넣어주는 순서나 존재 유무가 상관없음

아무것도 안 넣으면 기본적으로 null 값으로 들어감