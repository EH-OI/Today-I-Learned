# 5차시(1/21) - domain 계층 어노테이션
### domain
- 멤버 변수는 무조건 Wrapper class 자료형으로 선언
	- 기본형은 null 불가(DB에서 null 받아오게 되면 자료형의 기본 값으로 넣어줌)
- Entity 어노테이션(domain에서 제일 중요)
	- 어디가 entity인지 알려줘서 jpa로 연결할 수 있게 해 줌
	- 이게 붙어 있으면 jpa에서 mapping 시켜주는 관리 대상
	- 영속성 컨텍스트에서 관리  cf) Bean은 application context에서 관리
	- 즉, 영속성 컨텍스트에서 관리할 것을 선언하는 어노테이션
- Table 어노테이션
	- 어디가 테이블인지 명시
	- name(없으면 class name 따라감), 제약 조건 등이 들어가 있음
- Getter, Setter 어노테이션
	- 멤버 변수 관련
	- Setter는 보통 domain 단에서 쓰지 않음
		- Human error 발생 가능
		- 도메인의 비즈니스 로직 안에서 일관되게 값을 변경하지 못하게 됨 -> 값 변경 통제 필요
		- 보통 update, withdraw 메소드를 따로 만들어서 대신 사용
- Id 어노테이션
	- entity(해당 테이블)의 pk
	- 해당 컬럼의 이름 어떻게 짓든 상관없이 jpa의 findById 메소드로 찾을 수 있음
- GeneratedValue 어노테이션
	- 해당 Id를 어떻게 생성할지(생성 전략)
	- 자동으로 DB 단에서 pk가 들어감
- Column 어노테이션
	- column을 인지시켜줌
	- name(실제 DDL에 들어가는 이름 지정, 없으면 멤버 변수 이름 따름, mysql은 대소문자 구분 못하니 snake_case 사용하는 convention 있음), nullable, updatable(false로 두면 생성되는 순간부터 값 바꿀 수 없게 할 수 있음), length, columnDefault, columnDefinition(도메인 제약조건, mysql 문법으로 써야 하기 때문에 많이 사용하면 mysql에 종속적이게 될 수 있음) 등의 속성 있음
		- cf) convention - 개발 시 정해두는 코드 짜는 방식(규약)
		- column의 값을 바꾸지 못하게 하고 싶으면 `final`로 선언하지 말고 `updatable=false`로 두기
	- 날짜 쓰고 싶으면 무조건 `java.time.LocalDate` 쓰는 것 권장
		- Hibernate가 알아서 바꿔 줌
		- *Security에서는 `java.util.Date`을 써야 함(그에 맞춰 구현되어 있음)*
- Enumerated
	- Enum 값 setting
	- 보통 String으로 많이 씀
		- Enum값 추가, 삭제 시 String이 아니면 DB 값이 그냥 1, 2, 3으로 들어가서 순서 바뀜
		- String은 DB에서 toggle 형식으로 보여줌
		- 0, 1만 쓸 때는 tiny int로 써도 됨
			- bool 값도 tiny int로 들어감 -> b(0), b(1)처럼 사용

### repository
- DB에 query 날려서 받아오는 계층
- jpa repository가 비교적 최신
- jpa 기본 내장 메소드 쓰거나(save 등),  query annotation 써서 overriding으로 새로운 메소드 만들어 사용해 데이터 받아올 수 있음
- Page 클래스
	- 페이지네이션에 사용
- Optional 클래스
	- `findById()`로 받아올 때 optional 객체로 null 여부 `nullPointException` 없이 미리 확인 가능
	- list는 null이 안 들어와서 괜찮음(`isEmpty()` 메소드로 확인 가능)
- 기본적으로 domain 클래스의 객체 반환(list일 경우 해당 객체 list 반환)
	- dto나 interface 만들어서 필요한 column만 받아올 수도 있음
- `@Repository`
	- `public interface UserRepository extends JpaRepository<User, Long> {}`
		- 제네릭 타입으로 domain 클래스와 pk 타입을 넣어 줌
		- save() 등의 관련 메소드 자동 생성
			- Service단 등에서 주입받아 사용
				- `private final UserRepository userRepository;`
				- `userRepository.save(newUser);`

### dto
- 멤버 변수는 `private final`로 선언
- Getter 어노테이션 써야 Service단 등에서 값 사용 가능
- RequiredArgsConstructor 써야 Service 단에서 사용 가능
- 날짜는 `LocalDate` 타입의 멤버 변수 사용
	- @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd", timezone = "Asia/Seoul") 붙여 줘야 String을 파싱해서 `LocalDate` 타입으로 넣어 줌

### service
- service 어노테이션
	- 서비스라는 것 명시해 줌
- transactional 어노테이션
	- 메소드 하나가 하나의 transaction(모든 메소드를 트랜잭션으로 관리)
	- 트랜잭션 관리에 사용
	- 트랜잭션 이름, isolation level(read only 등 5개) 등의 속성 있음
	- 트랜잭션 실패 시 어떤 걸 실행시킬지 지정 가능
	- transaction after commit annotation
		- 커밋 이후에 뭐 실행시킬지 지정 가능
- 생성자 어노테이션
	- repository 객체를 미리 생성해 Bean으로 등록하고 IoC 컨테이너에서 관리
	- 새로 객체를 생성하는 것이 아니라 해당 Bean을 주입받아야 함
		- `private final`로 선언한 repository 타입 변수로 주입 받을 수 있음
		- 내부 메소드(생성자 포함)에서는 객체 만들어 사용
	- RequiredArgsConstructor 어노테이션
		- autowired가 deprecated 되고 이걸로 대체
		- 필요시에만 생성자 주입
		- No(아무것도 없는 기본 생성자), All(모든 멤버변수), Required(필요한 것만)가 있음
		- domain, dto, service에 각각 달아줘야 함
	- 생성자 위에 Builder 어노테이션 달면 빌더 패턴으로 생성자 매개변수 순서에 상관 없이 생성 가능
		- `User newUser = User.builder().name(userDto.getName()).sex(userDto.getSex()).build();`
	- 사용할 domain 클래스와 dto 클래스에도 붙여 줘야 함
- Slf4j 어노테이션
	- 로그 찍어볼 때 사용
	- 이거 말고 그냥 `System.out.println()`으로 찍어도 로그에 뜸
- 각 엔드포인트에 요청 들어오면 controller단에서 거기에 맞는 Service의 메소드들을 호출함
	- 엔드포인트 매핑은 dispatcher servlet에서 수행
- 회원가입의 경우, dto단에 선언한 클래스 객체를 받는 `createUserRepository`함수 필요
	- 보통 `boolean` 반환하게 함