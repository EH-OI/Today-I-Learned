WAS, 앱 어플리케이션, 웹 서버

- 웹 서비스 아키텍처 WAS, Web Server, Web Application
    1. Web Server : http, tls(웹사이트나 애플리케이션 간 데이터를 안전하게 주고받기 위해 데이터를 암호화하고 통신 상대를 인증하는 보안 프로토콜**)** 연결, 프록시랑 로드밸런서(클라이언트의 요청(트래픽)을 여러 대의 서버에 균등하게 분산시켜 특정 서버의 과부하를 막고, 애플리케이션의 가용성과 응답 시간을 최적화하는 기술 또는 장치)**,** 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램→ 대표적으로 Apache
        
        클라이언트로부터 http 요청 받고 이를 WAS로 보냄 
        
    2. WAS(Web Application Server) : JSP, Servlet 구동 환경을 제공해주므로 웹 컨테이너 혹은 서블릿 컨테이너(대표적인 WAS : tomcat) ,  동적 서버 콘텐츠를 수행하는 것으로 주로 데이터베이스 서버와 같이 수행
        
        → 웹 컨테이너 : 웹 서버가 보낸 JSP, PHP 등의 파일을 수행한 결과를 다시 웹 서버로 보내는 역할
        
    3. Web Application : 사용자가 웹을 이용해서 웹 서버에서 기능을 제공하는 소프트웨어. 즉, 우리가 작성해야할 스프링 코드
- 동작 과정
    
    Client - **MiddleWare Server(web server, was)** - DB Server
    
    1. Client는 단순히 요청만 중앙에 있는 미들웨어 서버에게 보낸다.
    
    2. 미들웨어 서버에서 대부분의 로직이 수행된다.
    
    3. 데이터 조작 관련 task는 DBMS에게 부탁한다.
    
    4. 로직 결과를 Client에게 전송한다.
    
    → 비즈니스 로직을 Client와 DBMS 사이의 미들웨어 서버에서 동작하게 함으로써 Client는 입력과 출력만 담당한다.
    
    ![image.png](attachment:ae85309b-0a4a-470e-8a80-70749e63bd70:image.png)
    

- Spring
    1. spring을 배우는 이유 : js가 더 가볍지만 spring(전자정부프레임워크)
    2. spring : 자바로 된 프레임워크
    3. 서블릿(Servlet) : 서버에서 실행되다가 웹 브라우저에서 요청을 하면 해당 기능을 수행한 후 웹 브라우저에 결과를 전송 →JSP 자바 기술
    4. 서블릿 컨테이너
    5. 장점
        1. POJO 기반의 구성 : Plain Old Java Objectd의 약자로 Java Bean 객체가 대표적(getter, setter) → 특정 기술이나 프레임워크에 종속되지 않는 순수한 자바 객체
        2. IoC(Inversion of Control) : 일반적인 Java 객체를 new로 생성하여 개발자가 관리하는 것이 아닌 Spring Container에 모두 맡김(즉, 개발자에서 -> 프레임워크로 제어의 객체 관리의 권한이 넘어갔음으로 "제어의 역전")
            
            → IoC 컨테이너 : 스프링 프레임워크도 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너 스프링 컨테이너라고도 한다.
            
            1. DI(Dependency Injection) : 객체 간의 의존성을 프레임워크가 주입하는 개념, 객체가 직접 의존하는 객체를 생성하거나 참조하는 대신, 각 클래스간의 의존관계를 빈 설정(Bean Definition) 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것
                
                의존성 주입의 방법
                
                1. 필드 주입 : 필드에 @Autowired 어노테이션만 붙여주면 자동으로 의존성 주입
                2. setter 주입(수정자 주입)
                3. 생성자 주입 : 필수 의존성을 명확히 할 수 있고, 객체를 final(불변)으로 만들 수 있음.
                    
                    → final로 선언한 생성자 주입 방식은 null이 불가능
                    
            2. DL : 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lockup하는 것
                
                → @Lookup 어노테이션이 달린 메서드가 호출될 때 스프링이 bean을 찾아서 리턴
                
        3. 컴포넌트 스캔과 자동 의존관계 설정 : component scan은 @component가 붙은 클래스를 찾아 1개의 객체만 생성(singleton) @component를 상속한 @Controller, @Service, @Repository에도 딱 1개의 객체 생성. 그리고 이를 ApllicationContext(스프링 컨테이너)에 넣어두는데 이를 Bean이라고 함.
            
            스프링 Bean은 싱글톤으로 관리되어 메모리를 절약하지만, 상태(State)를 가지면 안 된다(Stateless 해야 한다) Singleton Bean은 앱이 켜질 떄 Heap 메모리에 한 번 생성되고 앱이 꺼질 때까지 계속 살아있지만 메소드 내부 변수는 Stack으로 객체 자체는 Heap에 생기지만 GC(galbage collector)의 대상이 된다.
            
        4. AOP(관점 지향 프로그래밍) : 로깅, 보안, 트랜잭션(db 관리)처럼 여러 곳에 반복적으로 나타나는 횡단 관심사, 애플리케이션의 핵심 비즈니스 로직과 관련 없는 부가적인 기능들을 모듈화하여 코드의 중복을 줄이고 유지보수성을 향상시키는 데에 주로 활용

요청(request) : 클라이언트가 요청을 보냄

dispatcher 서블릿 : 모든 요청을 가장 먼저 받음(Front Controller 패턴)

handlermapping : 이 요청(url)을 처리할 controller 찾음

controller : 실제 개발자가 작성한 비즈니스 로직 수행

viewresolver : 결과를 보여줄 페이지(JSP, HTML)을 찾거나 JSON 데이터를 반환

객체들은 독립적으로 동작하는 것 보다 서로 상호작용하여 동작하는 경우가 많은데 이렇게 상호작용하는 객체를 ‘객체의 의존성’

Bean : 스프링 컨테이너(IoC 컨테이너)에 등록한 객체들

Bean 등록하는 방법

→ 컴포넌트 스캔과 자동 의존관계 설정

→ 자바 코드 : 설정 클래스를 만드로 @Configuration 어노테이션을 클래스 선언부 위에 추가 후 특정 타입을 리턴하는 메소드를 만드로, @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성

BeanFactory
- BeanFactory 계열의 인터페이스만 구현한 클래스는 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공한다.

 ApplicationContext
- Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.
- 스프링의 각종 부가 기능을 추가로 제공한다.

- BeanFactory 보다 더 추가적으로 제공하는 기능

질문 그림에서 보이는 web application은 미들웨어에 존재한다고 봐도 되는지
